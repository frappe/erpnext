# ERPNext - web based ERP (http://erpnext.com)
# Copyright (C) 2012 Web Notes Technologies Pvt Ltd
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# Please edit this list and import only required elements
import webnotes

from webnotes.utils import add_days, add_months, add_years, cint, cstr, date_diff, default_fields, flt, fmt_money, formatdate, generate_hash, getTraceback, get_defaults, get_first_day, get_last_day, getdate, has_common, month_name, now, nowdate, replace_newlines, set_default, str_esc_quote, user_format, validate_email_add
from webnotes.utils.email_lib import sendmail
from webnotes.model import db_exists
from webnotes.model.doc import Document, addchild, getchildren, make_autoname
from webnotes.model.doclist import getlist, copy_doclist
from webnotes.model.code import get_obj, get_server_obj, run_server_obj, updatedb, check_syntax
from webnotes import session, form, is_testing, msgprint, errprint

sql = webnotes.conn.sql
set = webnotes.conn.set
get_value = webnotes.conn.get_value

# -----------------------------------------------------------------------------------------


class DocType:
	def __init__(self,doc,doclist=[]):
		self.doc = doc
		self.doclist = doclist
	
	def get_project_details(self):
		cust = sql("select customer, customer_name from `tabProject` where name = %s", self.doc.project)
		if cust:
			ret = {'customer': cust and cust[0][0] or '', 'customer_name': cust and cust[0][1] or ''}
			return ret
	
	def get_customer_details(self):
		cust = sql("select customer_name from `tabCustomer` where name=%s", self.doc.customer)
		if cust:
			ret = {'customer_name': cust and cust[0][0] or ''}
			return ret
	
	def get_allocated_to_name(self):
		as_em = sql("select first_name, last_name from `tabProfile` where name=%s",str(self.doc.allocated_to))
		ret = { 'allocated_to_name' : as_em and (cstr(as_em[0][0]) + ' ' + cstr(as_em[0][1])) or ''}
		return ret

	# validate
	#--------------------------------------------	 


	def validate(self):
		if self.doc.exp_start_date and self.doc.exp_end_date and getdate(self.doc.exp_start_date) > getdate(self.doc.exp_end_date):
			msgprint("'Expected Start Date' can not be greater than 'Expected End Date'")
			raise Exception
		
		if self.doc.act_start_date and self.doc.act_end_date and getdate(self.doc.act_start_date) > getdate(self.doc.act_end_date):
			msgprint("'Actual Start Date' can not be greater than 'Actual End Date'")
			raise Exception

	# on update
	#--------------------------------------------	 
	
	def on_update(self):
		if self.doc.status =='Open' and self.doc.allocated_to:
			if self.doc.task_email_notify:
				self.send_notification()
			if self.doc.exp_start_date:
				sql("delete from tabEvent where ref_type='Task' and ref_name=%s", self.doc.name)
				self.add_calendar_event()
			else:
				msgprint("Tip: Add an expected start date to create a calendar event.")
			
			
	def validate_for_pending_review(self):
		if not self.doc.allocated_to:
			msgprint("Please enter Allocated To.")
			raise Exception
		self.validate_with_timesheet_dates()
		
	#Sent Notification
	def send_notification(self):
		i = {
			'name' : self.doc.name,
			'senders_name': self.doc.senders_name,
			'opening_date': self.doc.opening_date,
			'exp_start_date': self.doc.exp_start_date,
			'exp_end_date' : self.doc.exp_end_date,
			'subject' : self.doc.subject,
			'project': self.doc.project,
			'review_date': self.doc.review_date,
			'description': self.doc.description
		}

		task_label = '[Task Updated] '
		if self.doc.creation==self.doc.modified:
			task_label = '[New Task] '

		msg2="""<h2>%(name)s</h2>
			<p>This is a Notification for the task %(name)s that has been assigned / updated to you 
				by %(senders_name)s on %(opening_date)s</p>
			<p><b>Subject:</b> %(subject)s </p>
			<p><b>Project:</b> %(project)s</p>
			<p><b>Review Date:</b> %(review_date)s</p>
			<p><b>Expected Start Date:</b> %(exp_start_date)s</p>
			<p><b>Expected End Date:</b> %(exp_end_date)s</p>
			<p><b>Details:</b> %(description)s</p>
			<p>(This notification is autogenerated)</p>""" % i
		sendmail(self.doc.allocated_to, msg=msg2,subject= task_label + self.doc.subject)
	
	#validate before closing task
	def validate_for_closed(self):
		self.check_non_submitted_timesheets()
		self.get_actual_total_hrs()
	
	def check_non_submitted_timesheets(self):
		chk = sql("select t1.name from `tabTimesheet` t1, `tabTimesheet Detail` t2 where t2.parent=t1.name and t2.task_id=%s and t1.status='Draft'", self.doc.name)
		if chk:
			chk_lst = [x[0] for x in chk]
			msgprint("Please submit timesheet(s) : "+','.join(chk_lst)+" before declaring this task as completed. As details of this task present in timesheet(s)")
			raise Exception
	
	#calculate actual total hours taken to complete task from timesheets
	def get_actual_total_hrs(self):
		import datetime
		import time
		chk = sql("select t2.act_total_hrs from `tabTimesheet` t1, `tabTimesheet Detail` t2 where t2.parent = t1.name and t2.task_id = %s and t1.status = 'Submitted' and ifnull(t2.act_total_hrs, '')!='' order by t1.timesheet_date asc", self.doc.name)
		if chk:
			chk_lst = [x[0] for x in chk]
			actual_total = total =0
			
			for m in chk_lst:
				m1, m2=[], 0
				m1 = m.split(":")
				m2 = (datetime.timedelta(minutes=cint(m1[1]), hours=cint(m1[0]))).seconds
				total = total + m2
			
			actual_total = time.strftime("%H:%M", time.gmtime(total))
			set(self.doc, 'act_total_hrs', actual_total)
	
	# validate and fetch actual start and end date
	def validate_with_timesheet_dates(self):
		chk = sql("select t1.name, t1.timesheet_date from `tabTimesheet` t1, `tabTimesheet Detail` t2 where t2.parent = t1.name and t2.task_id = %s and t1.status = 'Submitted' order by t1.timesheet_date asc", self.doc.name, as_dict=1)
		if chk:
			if self.doc.act_start_date:
				if chk[0]['timesheet_date'] > getdate(self.doc.act_start_date) or chk[0]['timesheet_date'] < getdate(self.doc.act_start_date):
					msgprint("Actual start date of this task is "+cstr(chk[0]['timesheet_date'])+" as per timesheet "+cstr(chk[0]['name']))
					raise Exception
			else:
				self.doc.act_start_date = chk[0]['timesheet_date']
			
			if self.doc.act_end_date:
				if chk[len(chk)-1]['timesheet_date'] < getdate(self.doc.act_end_date) or chk[len(chk)-1]['timesheet_date'] > getdate(self.doc.act_end_date):
					msgprint("Actual end date of this task is "+cstr(chk[len(chk)-1]['timesheet_date'])+" as per timesheet "+cstr(chk[len(chk)-1]['name']))
					raise Exception
			else:
				self.doc.act_end_date = chk[len(chk)-1]['timesheet_date']
	
	def set_for_review(self):
		self.check_non_submitted_timesheets()
		self.validate_for_pending_review()
		self.get_actual_total_hrs()
		self.doc.review_date = nowdate()
		self.doc.status = 'Pending Review'
		self.doc.save()
		return cstr('true')
	
	def reopen_task(self):
		self.doc.status = 'Open'
		self.doc.save()
		return cstr('true')
	
	def declare_completed(self):
		if self.doc.status == 'Open':
			self.validate_for_pending_review()
			self.doc.review_date = nowdate()
		else:
			self.validate_with_timesheet_dates()
		self.validate_for_closed()

		self.doc.closing_date = nowdate()
		self.doc.status = 'Closed'
		self.doc.docstatus = 1
		self.doc.save()

		self.remove_event_from_calender()
		return cstr('true')
		
	def remove_event_from_calender(self):
		sql("delete from tabEvent where ref_type='Task' and ref_name=%s", self.doc.name)
		
	def cancel_task(self):
		chk = sql("select distinct t1.name from `tabTimesheet` t1, `tabTimesheet Detail` t2 where t2.parent = t1.name and t2.task_id = %s and t1.status!='Cancelled'", self.doc.name)
		if chk:
			chk_lst = [x[0] for x in chk]
			msgprint("Timesheet(s) "+','.join(chk_lst)+" created against this task. Thus can not be cancelled")
			raise Exception
		else:
			self.doc.status = 'Cancelled'
			self.doc.docstatus = 2
			self.remove_event_from_calender()
		self.doc.save()
		return cstr('true')

	
	def add_calendar_event(self):
		""" Add calendar event for task in calendar of Allocated person"""
		event = Document('Event')
		event.owner = self.doc.allocated_to
		event.description = self.doc.subject 
		event.event_date = self.doc.exp_start_date and self.doc.exp_start_date or ''
		event.event_hour =  self.doc.event_hour and self.doc.event_hour or '10:00'
		event.event_type = 'Private'
		event.ref_type = 'Task'
		event.ref_name = self.doc.name
		event.save(1)
